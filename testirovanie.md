# MyHomeWork
Какова разница между абстрактным классом и интерфейсом?
1) Абстрактный класс  описывает сущность объекта, интерфейс  -  свойство объекта, отделенное от понятия самого объекта.
2) Абстр.класс может содержать частичную или полную реализацию методов, Инт. - нет.
3) Абстр.класс может содержать не-final поля, поля Интерфейса – по умолчанию static final.
4) Методы интерфейса всегда public abstract (часто опускаются, для “чистоты интерфейса”), у абстрактного класса методы могут быть всех 4х типов доступа (public-protected-default-private), и может вообще не содержать абстрактных методов (например полезно, если просто хотим запретить создание экземпляров)
5) Абстр.класс реализуется расширением с помощью extends, интерф – имплементируется с пом. Implements.

Как «насильно» вызвать сборку мусора?
C помощью System.gc() можно ПОПЫТАТЬСЯ ПОПРОСИТЬ виртуальную машину сделать сборку мусора, и далеко не факт – что этот факт произойдет. Сборщим мусора и так работает как пчелка и следит за тем, чтобы удалять из heap объекты, ссылки на которые уже потеряны.  К тому же выполнять сборку мусора, когда состояние памяти не является критическим, скрее всего он не будет (затратно).

Когда требуется явное приведение классов?
Явное приведение классов требуется, когда есть риск потери данных – то есть при нисходящем (приведение родителя к ребенку) преобразовании. Восходящее (от ребенка к родителю, то есть к более общему типу) преобразование происходит неявно.

Чем конструкторы отличаются от других методов?
По сути, роль конструктора – дать объекту жизнь, и фактически, его можно назвать статическим методом. Конструктор всегда присутствует в любом классе (если не задано конструкторов явно – то конструктор будет по умолчанию, ежели задается вручную, то конструктор по умолчанию “перезаписывается”). Имя конструктора всегда совпадает с именем класса, и (в отличие от метода) – не имеет возвращаемого типа. И конструкторы, и методы можно перегружать (варьировать число или типы параметров). Конструкторы (в отличие от методов) нельзя унаследовать.

Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Можно, с помощью ключевого слова this (но только один конструктор можно вызвать, причем вызов должен находиться первой строкой в конструкторе)

В чем разница между JDK и JRE?
JRE – Java runtime environment – среда, которая содержит в себе JVM (java virtual machine, виртуальная машина – виртуальная машина, главный исполняющий компонент, который интерпретирует байт-код программы),  а так же содержит минимальный набор библиотек java и набор файлов для запуска java-приложений. Не содержит в себе компонентов, необходимы для разработки приложений.
JDK (Java development kit) содержит в себе полный набор для разработки приложений, включая полноценную библиотеку java, компилятор и средства для дебага программ.

Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Да, поскольку IOException – явлется родителем класса ФайлНотФаунд (то есть, более общим исключением), и если его поставить первым – он будет ловить все исключения, включая своих деток. Таким образом, FileNotFoundException будет недостижим в коде. Исклчения необходимо расставлять по порядку от более специлизированным к более общим.

Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Во-первых, nested классы (вложенные) могут быть 4х типов:
1) статические
2) внутренние (это был вопрос с небольшим подвохом? =)
3) локальные (в методах) (!)
4) анонимные
Если речь идет вложенном классе В МЕТОДЕ, значит речь, скорее всего, либо о локальном, либо об анонимном вложенном классе.
У них есть доступ ко всем членам внешнего класса, даже если они приватные. (У них есть неявная ссылка на экземпляр внешнего класса). Только у статического вложенного класса отсутствует неявная ссылка на экземпляр внешнего).

Как подкласс может обратиться к методу или конструктору из суперкласса?
С помощью ключевого слова super. Такое обращению обязательно должно стоять первой строчкой. Причем, если у базового класса есть конструктор без параметров по умолчанию, компилятор вызовет super() сам, автоматически.

В чем разница между очередью и стеком?
Очередь работает по принципу FIFO (First in first out, первый пришел, первый ушел).
Стек – по принципу LIFO (last in first out, последний пришел, первым ушел), - например, стопка тарелок.

Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
Первое что приходит в голову - языки, основанные на Java, но взявшие от нее хорошие моменты, и убравшие (или улучшившие) плохие моменты. Возможно, язык Котлин, или другие... 

Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?
Паттерн Наблюдатель. Класс А (слушатель) должен зарегистрироваться у класса В (наблюдатель) (по сути, это звучит как “я хочу у тебя зарегистрироваться, чтобы узнавать о нужных мне изменениях”. При этом наблюдатель отслеживает изменения и оповещает о них всех зарегистрированных слушателей.
Паттерн Наблюдатель используется, например, в “Listeners”, c по мощью которых можно отследить выход мышки за пределы окна, и прочие подобные штучки. Так же входит в состав паттерна MVC (model-view-controller) (View регистрируются в модели, чтобы узнавать о том, что модель изменилась).

Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Обычные классы можно помечать только 2 модификаторами: pulic (видны всем и отовсюду), и default (видны только в пределах пакета). То есть, ничего не указывать (= default)

Чем отличается статический внутренний класс от просто внутреннего класса?
Вопрос выше частично раскрывал данный (во внутреннем (inner) классе есть неявная ссылка на экземпляр внешнего класса, значит у него есть доступ ко всем членам внешнего класса, даже приватным. У статического класса такого преимущества нет.
Зато во внутреннем классе нельзя объявлять статические методы и поля. 

можно ли обратиться к не-статической переменной из статического метода?
Статические переменные относятся к понятию КЛАССА, нестатические – к понятию ОБЪЕКТА (то есть, к экземпляру класса).Статические переменные загружаются при первом обращении к членам класса (например, ИмяКласса.имяПеременной) – (для обращения к ним не требуется создания экземпляра), и всего один раз. Нестатические переменные отображают состояние конкретного объекта (доступ: имяЭкземпляра.имяПеременной). У них разный “жизненный цикл”, соответственно нельзя вызвать нестатическую переменную из статического метода.

какие типы данных есть в Java?
1) Примитивные:
byte (1 байт)
short (2 байта)
integer (4 байта)
long (8 байт)
float (4 байта)
double (8 байт)
char (2 байта) – или 1? 
boolean (1 байт)

2) Ccылочные
String
Классы-оболочки для примитивов
Массивы
Классы
Интерфейсы
…


Чем отличаются переопределение (Override) и перегрузка (Overload)
Переопределение – в контексте одного класса, когда методы с одинковым именем, но с разным списком параметров (отличие либо количеством, либо типом входных параметров). Смена возвращаемого методом типа не считается за переопределение.

Перегрузка – возможна только в контексте полиморфизма. Когда классы наследуют методы от родительского класса (или реализуют интерфейс), но каждый каждый реализует поведение по-своему.

Статический метод нельзя переопределить, и если создать в потомке метод, с таким же именем как в родителе, произойдет shadowing (произойдет сокрытие метода родителя).
К слову сказать, “+” является перегруженным – либо он выполняет арифметические операции, либо конкатенацию строк (соединение).

Что такое итератор?
Итератор – объект, с помощью которого можно получить доступ к каждому элементу коллекции/массива (главное условие – объекты должны быть iterable). Невозможно “перескочить” с объекта на объект через несколько “голов”.
В управляющем операторе for-each как раз неявно присутствует итератор, поэтому все так просто с виду ;)

Перечислите основные категории исключительных ситуаций
Дерево наследования исключительных ситуаций:
throwable наследуется от object. От throwable наследуется Error, Exception.
Checked exceptions (проверяемые) – это Exception и его наследники (кроме RuntimeException). Обязательно должны быть обработаны с помощью try-catch-finally, или объявить, что метод выбрасывает исключение (throws). 
Unchecked exceptions (непроверяемые) – Error и его наследники.


Какая разница между throw и throws?
С помощью throw можно самостоятельно возбудить какое-либо исключение. Throws указывается у метода, который может возбуждать исключение, но не обрабатывает его. Тогда это исключение будет пробрасываться выше, пока не будет обработано. Если не обработать это исключение и в методе main(), то программа будет завершена.

Зачем нужен блок finally?
Finally выполняется в любом случае (за исключением, если в try или catch не произошло завершения или ошибки JVM). Следовательно, с помощью него можно закрыть ресурсы (например, файлы).
С java 1.7  имеет место быть “try c ресурсами”, который значительно упрощает это. Пример:
try (Scanner scanner = new Scanner(System.in)) {
	// …
} - здесь уже ресурс уже закрыт. Эта запись эквивалентра записи с finally, c явным закрытием ресурса.

Что такое finalize?
finalize, по сути является “исполнителем последнего желания”,и вызывается сборщиком мусора перед удалением объекта. И крайне не рекомендуется к использованию, по причине выше (не факт, что сборка мусора будет произведена).

Перечислите все виды внутренних классов
(Частично выше).
Анонимные классы – когда имя класса нам не нужно совсем, и описываем его прямо в месте объявления экземпляра.
Название класса будет выглядеть: 
ИмяВнешнегоКласса$номер_по_порядку.
$ - разделитель внешнего и внутреннего класса
